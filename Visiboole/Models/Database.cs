/*
 * Copyright (C) 2019 John Devore
 * Copyright (C) 2019 Chance Henney, Juwan Moore, William Van Cleve
 * Copyright (C) 2017 Matthew Segraves, Zachary Terwort, Zachary Cleary
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.

 * You should have received a copy of the GNU General Public License
 * along with this program located at "\Visiboole\license.txt".
 * If not, see <http://www.gnu.org/licenses/>
 */

using System;
using System.Collections.Generic;
using System.Text.RegularExpressions;
using VisiBoole.ParsingEngine.ObjectCode;
using System.Linq;
using VisiBoole.ParsingEngine.Statements;
using VisiBoole.Models;
using System.Text;

namespace VisiBoole.ParsingEngine
{
    /// <summary>
    /// The database containing useful data that is parsed by the parsing engine along with their corresponding accessor methods
    /// </summary>
	public class Database
	{
        /// <summary>
        /// Design header for the design.
        /// </summary>
        public DesignHeader Header { get; set; }

        /// <summary>
        /// All independent variables parsed by the parsing engine
        /// </summary>
		public Dictionary<string, IndependentVariable> IndVars { get; private set; }

        /// <summary>
        /// All dependent variables parsed by the parsing engine
        /// </summary>
        public Dictionary<string, DependentVariable> DepVars { get; private set; }

        /// <summary>
        /// All variables parsed by the parsing engine
        /// </summary>
        public Dictionary<string, Variable> AllVars { get; private set; }

        /// <summary>
        /// Dictionary of variable namespaces.
        /// </summary>
        private Dictionary<string, List<int>> VectorNamespaces;

        /// <summary>
        /// List of the expressions in the design.
        /// </summary>
        private Dictionary<string, NamedExpression> Expressions;

        /// <summary>
        /// Dictionary of variable dependency lists.
        /// </summary>
        private Dictionary<string, List<string>> DependencyLists;

        /// <summary>
        /// Dictionary of alternating clocks in the design.
        /// </summary>
        public Dictionary<string, bool> AltClocks;

        /// <summary>
        /// List of libraries included in the design.
        /// </summary>
        public List<string> Libraries { get; private set; }

        /// <summary>
        /// Dictionary of subdesigns in the design.
        /// </summary>
        public Dictionary<string, Design> Subdesigns;

        /// <summary>
        /// Dictionary of instantiations in the design.
        /// </summary>
        public Dictionary<string, DesignInstantiation> Instantiations { get; private set; }

        /// <summary>
        /// All statements generated by the parser.
        /// </summary>
        public List<Statement> Statements { get; private set; }

        /// <summary>
        /// Clock statements generated by the parser.
        /// </summary>
        public List<ClockAssignmentStmt> ClockStatements { get; private set; }

        /// <summary>
        /// Instantiation statements generated by the parser.
        /// </summary>
        public List<InstantiationStmt> InstantiationStatements { get; private set; }

        #region Accessor methods

        public Database()
        {
            // Clear design header
            Header = null;
            IndVars = new Dictionary<string, IndependentVariable>();
            DepVars = new Dictionary<string, DependentVariable>();
            AllVars = new Dictionary<string, Variable>();
            VectorNamespaces = new Dictionary<string, List<int>>();
            Expressions = new Dictionary<string, NamedExpression>();
            DependencyLists = new Dictionary<string, List<string>>();
            AltClocks = new Dictionary<string, bool>();
            Statements = new List<Statement>();
            ClockStatements = new List<ClockAssignmentStmt>();
            InstantiationStatements = new List<InstantiationStmt>();
            Instantiations = new Dictionary<string, DesignInstantiation>();
            Subdesigns = new Dictionary<string, Design>();
            Libraries = new List<string>();
        }

        /// <summary>
        /// Updates/adds the provided bit to the provided namespace.
        /// </summary>
        /// <param name="name">Namepsace to update/add</param>
        /// <param name="bit">Bit to add</param>
        public void UpdateNamespace(string name, int bit)
        {
            // If vector namespace doesn't exist
            if (!VectorNamespaces.ContainsKey(name))
            {
                // Create new namespace with the new bit
                VectorNamespaces.Add(name, new List<int>(new int[] { bit }));
            }
            // If vector namespace exists
            else
            {
                // If vector namespace doesn't contain the bit
                if (!VectorNamespaces[name].Contains(bit))
                {
                    // Get current component count
                    int componentCount = VectorNamespaces[name].Count;
                    // Get current max bit
                    int currentMaxBit = VectorNamespaces[name][0];
                    // If new bit is larger than the current max bit
                    if (bit > currentMaxBit)
                    {
                        // For all bits between the current max to the new max
                        for (int i = currentMaxBit + 1; i <= bit; i++)
                        {
                            // Add bit
                            VectorNamespaces[name].Insert(0, i);
                        }
                    }
                    // If new bit is smaller than the current max bit
                    else
                    {
                        // Get the current min bit
                        int currentMinBit = VectorNamespaces[name][componentCount - 1];
                        // For all bits between the min bit to the new min
                        for (int i = currentMinBit - 1; i >= bit; i--)
                        {
                            // Add bit
                            VectorNamespaces[name].Add(i);
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Returns a list of components for the specified vector namespace.
        /// </summary>
        /// <param name="name">Namespace of the variable</param>
        /// <returns>List of components that belong to the namespace</returns>
        public IEnumerable<string> GetVectorComponents(string name)
        {
            // If the vector namespace exists
            if (VectorNamespaces.ContainsKey(name))
            {
                // Start components list
                List<string> components = new List<string>();
                // For each bit in the vector's bits
                foreach (int bit in VectorNamespaces[name])
                {
                    // Combine namespace with the bit to get the component
                    components.Add($"{name}{bit}");
                }
                // Return components list
                return components;
            }
            // If the vector namespace doesn't exist
            else
            {
                // Return null for no list
                return null;
            }
        }

        /// <summary>
        /// Adds a variable to the collection of variables of the given type
        /// </summary>
        /// <typeparam name="T">The type matching the target collection of variables</typeparam>
        /// <param name="v">The variable to add to the collection of matching type</param>
        /// <returns>Returns true if the variable was successfully added</returns>
        public bool AddVariable<T>(T v)
        {
            Type varType = typeof(T);
            if (varType == typeof(IndependentVariable))
            {
                IndependentVariable iv = (IndependentVariable)Convert.ChangeType(v, typeof(IndependentVariable));
                if (!IndVars.ContainsKey(iv.Name))
                {
                    IndVars.Add(iv.Name, iv);
                }
                if (!AllVars.ContainsKey(iv.Name))
                {
                    AllVars.Add(iv.Name, iv);
                }
            }
            else
            {
                DependentVariable dv = (DependentVariable)Convert.ChangeType(v, typeof(DependentVariable));

                if (!DepVars.ContainsKey(dv.Name))
                {
                    DepVars.Add(dv.Name, dv);
                }
                if (!AllVars.ContainsKey(dv.Name))
                {
                    AllVars.Add(dv.Name, dv);
                }
            }
            return true;
        }

        /// <summary>
        /// Fetches a variable from the collection of variables matching the given type
        /// </summary>
        /// <typeparam name="T">The type of the collection of variables to search</typeparam>
        /// <param name="name">The string representation of the given variable to search for</param>
        /// <returns>Returns the variable if it was found, else returns null</returns>
		public Variable TryGetVariable<T>(string name) where T : Variable
		{
			Type varType = typeof(T);
			if (varType == typeof(IndependentVariable))
			{
				if (IndVars.ContainsKey(name))
					return IndVars[name];
			}
			else if (varType == typeof(DependentVariable))
			{
				if (DepVars.ContainsKey(name))
					return DepVars[name];
			}
			else if (varType == typeof(Variable))
			{
				if (AllVars.ContainsKey(name))
					return AllVars[name];
			}
			return null;
		}

        /// <summary>
        /// Converts an independent variable to a dependent variable.
        /// </summary>
        /// <param name="name">Variable to convert</param>
        public void MakeDependent(string name)
        {
            // Get the value of the variable
            bool value = IndVars[name].Value;
            // Remove variable from independent variables dictionary
            IndVars.Remove(name);
            // Remove variable from variables dictionary
            AllVars.Remove(name);
            // Add new dependent variable to the dictionaries
            AddVariable(new DependentVariable(name, value));
        }

        /// <summary>
        /// Returns an array of variables from the provided token.
        /// </summary>
        /// <param name="token">String of variables</param>
        /// <returns>An array of variables</returns>
        public IEnumerable<string> GetVariables(string token)
        {
            if (!token.Contains("{"))
            {
                return new string[] { token };
            }
            else if (!token.Contains(".d"))
            {
                token = token.Substring(1, token.Length - 2);
                return Parser.WhitespaceRegex.Split(token);
            }
            else
            {
                token = token.Substring(1, token.Length - 4);
                string[] variables = Parser.WhitespaceRegex.Split(token);
                for (int i = 0; i < variables.Length; i++)
                {
                    variables[i] = variables[i] + ".d";
                }
                return variables;
            }
        }

        /// <summary>
        /// Returns the value of the provided token.
        /// </summary>
        /// <param name="token">String of variables</param>
        /// <returns>Value of the provided token</returns>
        public int GetValue(string token)
        {
            if (char.IsDigit(token[0]))
            {
                // Return int converted value of token
                return Convert.ToInt32(token);
            }
            else if (token[0] != '{')
            {
                IndependentVariable indVar = TryGetVariable<IndependentVariable>(token) as IndependentVariable;
                DependentVariable depVar = TryGetVariable<DependentVariable>(token) as DependentVariable;
                if (indVar != null)
                {
                    if (indVar.Value) return 1;
                    else return 0;
                }
                else if (depVar != null)
                {
                    if (depVar.Value) return 1;
                    else return 0;
                }
                else
                {
                    return -1; // If variable doesn't exist
                }
            }
            else
            {
                // Create binary string builder
                StringBuilder binary = new StringBuilder();
                // For each variable in the token
                foreach (string var in GetVariables(token))
                {
                    // Add variable's value to binary string
                    binary.Append(GetValue(var));
                }
                // Return int converted binary string as value
                return Convert.ToInt32(binary.ToString(), 2);
            }
        }

        #endregion

        /// <summary>
        /// Toggles the value of the given variable in its corresponding collections
        /// </summary>
        /// <param name="variableName">The name of the variable to search for</param>
        public void FlipValue(string variableName)
        {
            if(IndVars.ContainsKey(variableName))
            {
                SetValue(variableName, !IndVars[variableName].Value);
            }
        }

        /// <summary>
        /// Sets specific value
        /// </summary>
        /// <param name="variableName"></param>
        /// <param name="value"></param>
        public void SetValue(string variableName, bool value, bool updateAltClocks = true)
        {
            if (IndVars.ContainsKey(variableName))
            {
                IndVars[variableName].Value = value;

                foreach (string dependent in DependencyLists.Keys)
                {
                    if (DependencyLists[dependent].Contains(variableName))
                    {
                        Expressions[dependent].Evaluate();
                    }
                }
            }
            else if (DepVars.ContainsKey(variableName))
            {
                DepVars[variableName].Value = value;

                foreach (string dependent in DependencyLists.Keys)
                {
                    if (DependencyLists[dependent].Contains(variableName))
                    {
                        Expressions[dependent].Evaluate();
                    }
                }
            }

            if (updateAltClocks)
            {
                if (AltClocks.Count > 0 && AltClocks.ContainsKey(variableName))
                {
                    if (!AltClocks[variableName] && value)
                    {
                        foreach (var clockStatement in ClockStatements)
                        {
                            if (clockStatement.Clock == variableName)
                            {
                                clockStatement.Tick();
                            }
                        }
                    }

                    // Update alternate clock value
                    AltClocks[variableName] = value;
                }
            }
        }

        /// <summary>
        /// Sets each binary value to the corresponding variable.
        /// </summary>
        /// <param name="variables">Variables to set</param>
        /// <param name="binary">Values to set</param>
        public void SetValues(IEnumerable<string> variables, string binary, bool tickAltClocks = true)
        {
            int i = -1;
            foreach (var variable in variables)
            {
                if (GetValue(variable) != char.GetNumericValue(binary[++i]))
                {
                    SetValue(variable, binary[i] == '1', tickAltClocks);
                }
            }
        }

        /// <summary>
        /// Updates all expression values then adds the expression to the expressions dictionary.
        /// </summary>
        /// <param name="expression">Expression to add</param>
        public void AddExpression(NamedExpression expression, string clock = null)
        {
            // Add expression to expressions list
            foreach (string dependent in expression.Dependents)
            {
                Expressions.Add(dependent, expression);
            }

            // If expression has an alternate clock and that alternate clock isn't in the alternate clocks dictionary
            if (clock != null && !AltClocks.ContainsKey(clock))
            {
                // Add new alternate clock to alternate clocks dictionary
                AltClocks.Add(clock, GetValue(clock) == 1);
            }
        }

        public void EvaluateExpressions(bool tickAltClocks = true)
        {
            foreach (var expression in Expressions.Values)
            {
                expression.Evaluate(tickAltClocks);
            }
        }

        /// <summary>
        /// Returns whether the provided variable has an existing dependency list.
        /// </summary>
        /// <param name="variable">Variable</param>
        /// <returns>Whether the provided variable has an existing dependency list</returns>
        public bool HasDependencyList(string variable)
        {
            return DependencyLists.ContainsKey(variable);
        }

        /// <summary>
        /// Tries to add a dependent and its dependencies to the database.
        /// </summary>
        /// <param name="dependent">Dependent</param>
        /// <param name="dependencyList">Dependent's dependencies</param>
        /// <returns>Whether the dependent and its dependencies were added to the database</returns>
        public bool TryAddDependencyList(string dependent, List<string> dependencyList)
        {
            //List<string> variablesToRemove = new List<string>();
            List<string> variablesToAdd = new List<string>();
            // Iterate through the dependency list
            foreach (string variable in dependencyList)
            {
                // If varaible in the dependency list has dependencies
                if (HasDependencyList(variable))
                {
                    // Get variable's dependency list
                    List<string> additionalDependencyList = DependencyLists[variable];
                    // If variable's dependency list contains the dependent
                    if (additionalDependencyList.Contains(dependent))
                    {
                        // Return false (cycle)
                        return false;
                    }

                    // Add new variables to addition list
                    variablesToAdd.AddNew(additionalDependencyList);
                }
            }

            dependencyList.AddNew(variablesToAdd);

            foreach (KeyValuePair<string, List<string>> dependecy in DependencyLists)
            {
                if (dependecy.Value.Contains(dependent))
                {
                    if (dependencyList.Contains(dependecy.Key))
                    {
                        return false;
                    }

                    // Add dependent's dependencies to the existing dependency
                    dependecy.Value.AddNew(dependencyList);
                }
            }

            DependencyLists.Add(dependent, dependencyList);
            return true;
        }
    }
}